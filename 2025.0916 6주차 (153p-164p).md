멀티 스레드 / 멀티 프로세스

멀티 프로세스 - 브라우저 탭 한 개 = 프로세스 하나.

| 종류      |                                                                                                                                                                                                                                                                                                        |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 멀티 프로세스 | 예시) 브라우저 탭 한개 = 프로세스 하나<br>(프로그램 하나가 여러 프로세스를 가질 수 있다.)<br>- 기본적으로 서로 다른 프로세스는 자원을 공유하지 X<br>- 파일, 입출력 장치 등이 독립적으로 할당.<br>- PID 도 각각 다르다.                                                                                                                                                              |
| 멀티 스레드  | 프로세스 하나를 스레드 단위로 나누어 동시 연산.<br> - 같은 프로세스의 작업이기 때문에 자원을 공유.<br> - 스레드 공유 자원 / 개별 자원이 나눠져 있다.<br><br>-하나의 스레드는 <br> **1) 스레드ID**<br> **2) 프로그램 카운터**<br> **3) 레지스터 값**<br> **3) 스택** <br> 등으로 구성된다. (1,2,3 은 PCB에, 4는 사용자 영역 메모리)<br><br><PCB 와 프로세스 메모리 형태 사진><br>![alt text](<사진/Pasted image 20250916182439.png>) |

**스레드 조인** 
일반적인 start와 다르게 join은 스레드를 생성한 스레드가 생성된 스레드를 기다려야 하는 방식의 명령어다.

프로세스 간 통신 (IPC, Inter-process comunication)

1. **공유 메모리**
   기본적으로 프로세스는 메모리(자원)를 공유하지 않지만 공유 메모리 영역을 할당해서 사용하게 되면 다른 프로세스의 메모리 값도 참조할 수 있게 된다.  같은 메모리 공간을 쓰고 읽기만 하여도 결과 상 프로세스 간의 통신이 된 것과 같다.
   (**레이스 컨디션**: 공유 메모리를 동시에 읽고 쓸 때 생기는 오류 -> 동기화/교착의 중요성)
2. **메시지 전달**
   메세지를 받는 수단과 보내는 수단이 명확하다.
   (시스템 콜 => send(), recv())
   대표적인 방법 
	- **파이프**: 단방향 프로세스 간 통신 도구
	  부모 -> 자식 프로세스 방향으로만 보낸다. (기본 pipe)
	  
	  Named pipe는 파일 시스템에 등록된 이름을 통해 다른 프로세스간 양방향 통신도 가능하다.
	  
	  ![alt text](<사진/Pasted image 20250916210030.png>)
	
	- **시그널** : 특정 신호가 발생했음을 알리는 비동기적 신호
	  
	  **인터럽트 과정과 유사**하게 하던 작업을 멈추고 시그널 핸들러를 실행한다.
	  다른 IPC와 다르게 직접 메세지를 주고 받지는 않는다.
	  
	  UNIX 시그널 함수![alt text](<사진/Pasted image 20250916202018.png>)
	  프로세스 종료 커맨드 ctrl + c 가 보여서 반가웠습니다.
	  
	- **소켓**: 
	  네트워크 기반 ICP
	  소켓은 프로세스 데이터 송수신을 위한 종착점이다.
	  서버-클라이언트 방식 구조에 많이 사용된다.
	- 소켓 통신의 흐름

	서버 측
	
	1. **소켓 생성**: `socket()`
	2. **IP와 포트 바인딩**: `bind()`
	3. **클라이언트 요청 대기**: `listen()`
	4. **연결 수락**: `accept()`
	5. **데이터 송수신**: `recv()`, `send()`
	6. **연결 종료**: `close()`
	
	클라이언트 측
	
	7. **소켓 생성**: `socket()`
	8. **서버에 연결 요청**: `connect()`
	9. **데이터 송신**: `send()`
	10. **응답 수신**: `recv()`
	11. **연결 종료**: `close()`
	   
	[소켓이란]
	   
	  ![alt text](<사진/Pasted image 20250916202243.png>)
	  ![alt text](<사진/Pasted image 20250916203223.png>)
	  
	  
	- **원격 프로시저 호출(RPC, Remote Procedure Call)**
	  **원격에 있는 함수를 로컬에서 호출하듯이 사용하는 통신 방식**
	  개발자는 네트워크 통신을 직접 다루지 않고, **함수 호출처럼 간단하게** 원격 작업을 수행할 수 있다.
	  
	  **동작 흐름**
	
		1. 클라이언트가 **원격 함수 호출**을 요청
		2. 클라이언트 Stub이 요청을 메시지로 변환
		3. 네트워크를 통해 서버 Stub으로 전달
		4. 서버가 해당 함수를 실행하고 결과를 반환
		5. 클라이언트가 결과를 받아서 처리
		   
		이 모든 과정이 함수 호출처럼 보이지만, 실제로는 네트워크를 통한 메시지 교환이다.
		
		실시간 메신저를 만들 때는 소켓 방식을 쓴다.
		![alt text](<사진/Pasted image 20250916204710.png>)
		
		멀티플레이어 게임을 만들 때 rpc 방식을 썼던 기억이 있어서
		왜 소켓 방식을 안 쓴 건지 의문이 들어 속도 비교.
		구현에 있어서 잦은 상태 변화, 함수 호출을 하는 게임에는 rpc 방식이 적합하다고 합니다.
		하지만 내부 처리 과정이 들어가서 속도를 느릴 수 있다고 합니다.
		(직렬화 / 역직렬화 / Stub 호출 / IDL 처리)
		
		콜오브듀티 같은 실시간 액션 게임은 UDP 방식의 소켓 통신으로 구현한다고 합니다.
		"총알 위치, 피격 판정 등 빠른 처리가 가능하고, TCP에 비해 신뢰성이 낮지만 게임 로직을 통해 패킷 손실을 줄인다"라고 합니다.
		
		![alt text](<사진/Pasted image 20250916205045.png>)
   
