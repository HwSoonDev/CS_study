
## 동기화

#### 동기화를 해야 하는 이유 (= 레이스 컨디션)
1) **공유 자원:** 프로세스와 스레드가 공유하는 자원(데이터)
2) **임계 구역:** 공유 자원에 접근하는 코드 중, 동시에 실행 했을 때 (읽기/쓰기) 문제가 생길 수 있는 코드.
3) **레이스 컨디션:** 임계 구역에 있는 코드를 동시에 실행 자원의 일관성이 손상되는 것.

#### 동기화를 한다는 것
 아래 두가지를 하는 것이다.
1) **상호 배제:** 동시에 접근해서는 안되는 자원에 하나씩만 접근하기.
2) **실행 순서 제어 :** 프로세스, 스레드를 올바른 순서대로 실행하기.

#### 동기화 기법
##### 1) **뮤텍스 락** (상호배제 락)
   자원에 동시 접근이 불가능하도록 상호 배제를 보장하는 동기화 도구
   
   락(lock)은 다른 프로세스가 접근하지 못하게 막는 것. 들어갈 때 락, 나갈 때 언락
   ```
   임계 구역에 접근하고자 한다면 반드시 락(lock)을 획득(acquire)해야 하고, 작업이 끝나면 해제(release)해야한다. 
   
   " aquire() -> release() "
   " lock() -> unlock()"
   ```
##### 2) **세마포**
   
   뮤텍스 => 하나의 공유 자원만 고려
   세마포 => 여러 공유 자원을 고려(일반적인 상황)
   
   n개의 공유 자원이 있다면, n개의 프로세스(스레드)가 동시에 들어갈 수 있다.
   
- **변수 S**:  사용가능한 공유자원의 개수
- **wait() :임계 구역 진입 전 호출**
  s를 1감소 시킨후 0이상이면 (자리가 남으면) 진입 아니면 대기(wait)
- **siganl(): 임계 구역 진입 후  작업 종료 시 호출**
  s를 1 증가 시킨 후 0이하면 대기 중인 프로세스가 있음.(프로세스 하나를 진입 시킨다) 0초과면 없음. 
##### 3) 모니터
   
- 조건 변수 (cv)
  wait(), signal() 함수는 공유 자원 진입 여부를 컨트롤하고, 이 컨트롤의 조건이 되는 변수가 있는 형태.
  
#### 스레드 안전

공유 자원에 동시 접근해도 안전한 스레드.
공유 자원에 동시 접근이 일어나도 레이스 컨디션에 걸리지 않는 스레드를 말한다.

예시 Java의 add 메서드는 동기화(synchonized) 구현이 되어 스레드 안전이다. ArrayList 클래스는 tmfpem dkswjsdl dkslek.
## 교착

= 동기화로 인해 발생하는 문제.
발생 조건

1) 상호 배제
2) 점유와 대기 (= 실행 순서 제어)
3) 비선점
4) **원형 대기**
   다른 프로세스가 점유하는 자원을 서로 기다리는 상황.
   
   **동기화로 구현**(1~3)하고, **원형 대기 상태**(4)에 빠지면 교착이 일어난다.
![alt text](<사진/Pasted image 20250923183939.png>)
   
#### 교착을 해소하는 방법
1) 예방
   
   교착 발생 필요 조건 4가지 중 하나라도 충족하지 않게 하는 방법.
   
   자원에 동시 접근을 하지 않게 하거나 
   (하나에 몰빵 = 선점) (3번 비선점) 
   점유를 하지 못하게 하거나 (1,2번 상호배제, 점유 대기)
   (다같이 사용하고 레이스 컨디션을 방관하자)
   하면 교착은 생기지 않지만, **동기화를 구현하지 않겠다는 뜻**..
   
   그래서 4번 밖에 없는데
   
   원형 대기를 해결하는 방법 = **스케쥴링**.

2) 회피
   
   .충분한 자원에서 일부 자원만 요구하는 상황만 유도하는 것. (=은행원 알고리즘)
   
2) 회복
   
   교착이 발생하면, 자원 분배를 막거나(선점), 강제종료하여 회복하는 방식


## 스케쥴링

#### 우선순위
프로세스 간에 우선순위가 있다.
**입출력 집중 프로세스**는 일반적으로 **CPU집중 프로세스**보다 우선순위가 높다.
(CPU 작업이 적어 먼저 처리해버리고 다음 입출력 인터럽트까지 CPU 집중 프로세스에 집중시키면 되기 때문...)

#### 스케쥴링 큐
프로세스는 CPU에 올리기 전 준비 큐와 **준비큐**에 올리기 전 **대기큐**가 있다.
대기큐는 프로세스 종류별로 모아져 있다.

선점형 vs 비선점형 스케쥴링

선점형은 CPU가 프로세스의 자원을 강제로 뺏을 수 있는 유형의 스케쥴링.
비선점형은 프로세스가 스스로 반납할 때까지 자원을 뺏을 수 없는 유형의 스케쥴링.


스케쥴링 알고리즘

1) **선입 선처리 (FCFS)** : 너무 오래 처리하는 프로세스가 앞에 있으면 대기 시간이 길어진다. (호위 효과)
2) **최단 작업 우선(SJF)** :  짦은 작업 먼저 수행
3) **라운드 로빈(RR)** : 선입 선처리 +  시간 제한 (타임 슬라이스)
4) **최소 잔여 시간(SRT)** : 최작우 + 타임 슬라이스
5) **우선순위 스케쥴링 (Primary):** 우선순위를 매겨서 높은 우선순위 먼저 수행. 낮은 우선 순위는 계속 밀려서 **아사할수도** 있음(영원히 실행 x), **에이징**(대기 시간을 가산점으로 부여하는 것)
6) **다단계 큐**: 우선순위 별로 준비 큐를 따로 만든다. 아사할 수 있다.
7) **다단계 피드백 큐**: 준비 큐 사이를 프로세스가 이동할 수 있다. 에이징 기법도 적용할 수 있다.

리눅스 스케쥴링

FCFS, RR은 생략

SCHED_NORMAL은 **가중치**로 프로세스의 **우선순위**와 **타임 슬라이스**를 정한다.
가중치가 높을 수록 더 먼저, 더 많은 시간 동안 CPU를 점유할 수 있다는 특징이 있다.

가중치 계산식은 복잡하므로 생략

RB 트리 (자료구조)

