
목차
0. 기술면접을 준비하는 자세
1. 컴퓨터 하드웨어
	1) cpu
	2) 메모리 (캐시메모리)
	3) 보조기억장치
	4) 입출력 장치
	5) 데이터 버스

2. 컴퓨터가 이해하는 것
	1) 데이터
	2) 명령어


## 기술면접을 준비하는 자세

### 1) 원리를 모르는 개발자는 개발자가 아니다
### 2) CS(컴퓨터 과학)은 암기 과목이 아니다

기술면접의 질문은 직무 상황과 일맥상통하는 것
원리를 이해하고 스스로 설명 할 수 있어야 실무에 대처할 수 있다.

단어 암기장 처럼 키워드를 암기한다고 되는 것이 아니다. 

| 키워드           | 내용                                                                             |
| ------------- | ------------------------------------------------------------------------------ |
| 트리 자료구조       | 그래프의 일종.<br>순환이 없는 정점(노드)와 간선() 구조<br>시작 노드부터 시작해서 각 노드를 한번씩 방문, 순회하여 돌아온다.    |
| TCP / IP 차이   | TCP 프로토콜 : 신뢰성과 무결성을 보장하는 전송 계층 프로토콜<br>IP 프로토콜 : 패킷을 목적지로 보내기 위한 네트워크 계층 프로토콜 |
| 프로세스 / 스레드 차이 | 프로세스 : 운영체제에서 자원을 할당하는 작업의 단위<br>스레드 :  프로세스를 이루는 실행 흐름 단위                     |
이런 식으로 키워드를 외운다고 해도
정작 나오는 건 활용 질문이다!

**???: 트리의 모든 노드를 순회하는 방법.** 
(이중 트리라면 전위, 중위, 후위 순회... )

**??? : 웹브라우저에 웹페이지가 구현되는 과정을 설명하시오** 
(Http, tcp, ip, 브라우저 렌더링 ...) 

**??? : 이 기능을 멀티 스레드로 구현한 것과 멀티 프로세스로 구현 한 것의 차이를 설명하세요.**
(뭘까용? 멀티 스레드면 cpu를 병렬로 할당할 수 있어서 하나의 프로세스를 빠르게 끝낼 수 있다?...)

대답할 수 없는 질문이 튀어나온다...

이에 대비하는 것이 CS 기술면접 대비.

1) 공통 지식 (컴퓨터 구조, 운영체제, 자료구조, 네트워크, 데이터베이스) -> 전 개발 분야에서 알아야 할 지식
2) 개별 지식 (언어, 프레임워크/라이브러리, 개발도구, 이력서 및 기업 전문성) -> 각 분야에 특화된 지식

이 책에서는 **'공통 지식'** 에 대해 다룬다.



컴퓨터 구조
## 컴퓨터 하드웨어 

#### CPU

데이터, 명령어를 읽고 해석하고 실행하는 곳.

1) **ALU** (Arithmetic an d Logic Unit, 산술논리연산장치)
	일종의 계산기. 명령어를 실제로 수행하는 곳 (덧셈, 곱셈, Jump, Move 등의 연산 회로가 모인 곳)
2) **CU** (Controll Unit, 제어 장치)
	 명령어를 제어 신호로 변환에 각 장치에 보내는 곳 메모리, 입출력장치 등으로 제어 신호를 보낸다.
3) **레지스터** (Register)
	 CPU 내부의 임시 저장장치 데이터와 명령어를 처리하는 과정의 중간 값을 저장한다.

#### 메모리 (=RAM)

실행 중인 데이터, 명령어를 저장하는 곳.

1) **주소**(Address) 로 접근 
2) **휘발성**

**캐시 메모리** 
:  CPU와 메모리 사이에 하나 이상 존재. CPU의 빠른 메모리 사용을 위해 보조하는 역할

#### 보조 기억장치

장기간 데이터 저장 장치

1) 비휘발성
2) HDD , SSD, USB, SD카드 등

#### 입출력 장치

모니터, 마우스, 키보드 (KVM)
(feat. 리눅스 KVM = 커널 기반 가상 머신)


### 메인보드 와 버스

메인 보드에서 컴퓨터 하드웨어를 이어주는 데이터 버스 가 존재한다.

##### Bus
Bus는 데이터가 오르고 내리는 경로 그 자체다. 버스 구조는 다양하게 쓰여서 개념만 알아두자
여기서는 cpu,메모리, 기억장치, 입출력장치가 데이터를 주고 받는 경로다.


## 컴퓨터가 이해하는 것

### 1) 데이터

#### 0과 1  = 이진 비트으로 데이터를 저장

#### 숫자 표현 - 비트(Bit)

##### 부동소수점
- **Floating Point** 
![alt text](<../사진/Pasted image 20250812185703.png>)
이게 가수인가 기수인가 헷갈리는데 둘 다 쓰는 표현인 듯 하다.
(옛날에 어디서 들었는데 둘 다 쓰는 이유.. 아마 가수가 지금 표현)

- **부동소수점이 유사치인 이유**

	 10진수에서 소수를 m x10^n  형태로 값을 쓴다면,
	 2진수에서는 m x 2^n 형태로 값을 쓸 수 있다.
	 
	 10진수에서 완벽하게 표현할 수 없는 무한 소수( 1/3 = 0.3333...)가 있는 것처럼, 2진수의 표현 방식에서도 무한 소수가 발생한다. (3진수라면 1 x 3^-1로 깔끔하게 표현 가능)
	 10진수로는 딱 떨어지는 수라도, 2진수로는 표현하지 못하는 소수가 있다. 
	 이런 수는 가장 가까운 2진수로 표현하게 되어서 유사치가 나온다.
	 
	 0.1 + 0.2 != 0.3 이 발생하는 이유.

#### 문자 표현 - 문자 인코딩 방식

문자도 이진 데이터로 저장한다. 
한 글자에 몇 비트를 할애할 것 인지에 따라 표현할 수 있는 문자 수가 달라진다.
약속된 통일형이 있어야 같은 문자를 표시하기 때문에 코드 규약이 있다.

| 인코딩 방식 | 한 글자 크기     | 설명                                                                                                                                                                                                                                                 |
| ------ | ----------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 아스키 코드 | 1byte=8bit  | 숫자, 문자(알파벳), 그 외 특수 문자 몇 개                                                                                                                                                                                                                         |
| EUC-KR | 2byte=16bit | 한글 표현이 가능 (모든 글자 조합 x)                                                                                                                                                                                                                             |
| 유니 코드  |             | 통합 문자 체계 (거의 모든 언어 표현 가능)<br><br>글자에 부여된 코드가 있고<br>이를 인코딩하는 방식도 따로 있다. <br><br>UTF-8, UTF-16, UTF-32 등이 인코딩 방식이다.<br>숫자가 높을 수록 더 많은 문자를 표현. (더 많은 비트를 사용)<br><br>우리나라는 UTF-32 선에서 정리<br><br>**가변 길이 인코딩** : UTF-8, UTF-16<br>**고정 길이 인코딩**: UTF-32 |
| base64 | 6byte=64bit | 이진 데이터 저장에 사용<br>64개 종류 문자로 데이터를 표현<br>(이진 데이터 )                                                                                                                                                                                                   |


### 2) 명령어

#### 명령어의 구조 (연산 코드 / 오퍼랜드)

| opcode                           | operand                                                                                            |
| -------------------------------- | -------------------------------------------------------------------------------------------------- |
| 연산 코드<br>연산자<br><br>명령어가 수행하는 동작 | 오퍼랜드<br>피연산자<br><br>명령어를 수행하는 대상.<br><br>데이터 자체일수도 있고,<br>데이터의 위치일 수도 있지만,<br>**주로 메모리 주소를 의미**한다. |

#### CPU의 연산 코드

cpu에 따라 연산코드(opcode)의 생김새는 다르지만,
공통적으로 가지고 있는 연산 코드는 있다.

| 데이터 전송      | 산술/논리 연산                            | 제어 흐름 변경                 | 입출력 제어                         |
| ----------- | ----------------------------------- | ------------------------ | ------------------------------ |
| MOVE        | ADD / SUBTRACT<br>MULTIPLY / DIVIDE | JUMP<br>CONDITIONAL JUMP | READ (INPUT)<br>WRITE (OUTPUT) |
| STORE       | INCREMENT<br>DECREMENT              | HALT                     | START IO                       |
| LOAD(FETCH) | AND / OR / NOT                      | CALL                     | TEST IO                        |
| PUSH        | COMPARE                             | RETURN                   |                                |
| POP         |                                     |                          |                                |

#### 기계어 / 어셈블리어 / 고급 언어 / 자연어

자연어 = 인간이 쓰는 언어.

| 명령어 종류 |                                                                                                                                        |
| ------ | -------------------------------------------------------------------------------------------------------------------------------------- |
| 기계어    | 1010101101011010<br>이진 코드로 명령어를 작성하는 방법 <br>한 눈에 코드의 의미를 읽어내기 어렵다.                                                                     |
| 어셈블리어  | push mov pop add sub ...<br>기계어의 명령어 단위를 끊어서 자연어 심볼로 나타낸 방법<br>조금 읽기 편한 형태로 번역한 것이다.<br><br>**CPU마다 명령어가 달라진다.** (CISC기반, RISC 기반....) |
| 고급 언어  | C, Java, python 등..<br>보다 자연어에 가깝고 멀티 플랫폼에서 개발(?)할 수 있다.<br>(CPU에 따라 명령어가 달라 지지 않는다.)                                                  |
"계층 레벨" 을 추가로 정리해야겠다.


#### 명령어 사이클

![alt text](<../사진/Pasted image 20250812194930.png>)
1) 인출 사이클에 메모리에서 명령어와 데이터를 CPU로 가져오고
2) 실행 사이클에서 연산을 수행한다.

3) 간접 사이클은 add( a, b) 처럼 명령어를 가져오고 데이터 a, b를 다시 또 가져와야 수행이 가능한 경우처럼 메모리 접근이 더 필요한 경우에 수행하는 사이클이다.
4) 인터럽트 사이클은 실행 사이클 도중에 인터럽트가 발생하면 수행하는 사이클이다. 
   (자세한 내용은 레지스터 공부 후 배운다.)
   
   주로 입출력 장치처럼 데이터 반환이 느린 기능을 수행할 때 인터럽트로 구성을 하는데, 평소에는 다른 명령어를 수행하면서 인터럽트를 각 스레드 종료 시점에 감시하고  인터럽트가 발생하면, 실행하던 명령어의 진행 상황을 임시로 백업해두고 인터럽트 사이클을 수행한다. 수행이 끝나면 다시 백업을 가져와서(인출), 실행 사이클을 수행한다. 