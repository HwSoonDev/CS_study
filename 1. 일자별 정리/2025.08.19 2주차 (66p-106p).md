
## 목차

- cpu
	- 레지스터
	- 인터럽트
	- cpu 설계 -> 성능 향상
	- 파이프라이닝
- 메모리
	- RAM
	- 메모리
	- 캐시 메모리


## CPU
### 레지스터

데이터와 명령어를 실행을 위해 저장하는 곳

| 레지스터 종류  |                                                                                                                                                                                  |
| -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 프로그램 카운터 |                                                                                                                                                                                  |
| 명령어 레지스터 | 해석할 명령어를 저장하는 곳.<br>CPU는 명령어 레지스터에 담긴 명령어를 해석하고 ALU 연산에 쓴다.                                                                                                                      |
| 범용 레지스터  | 데이터, 명령어, 주소 모두를 저장할 수 있는 범용.                                                                                                                                                    |
| 플래그 레지스터 | 플래그(=cpu 상태의 부가 정보)를 저장<br>부호 플래그: 연산 결과의 부호<br>제로 플래그: 연산 결과가 0인지<br>캐리 플래그: 올림수/빌림수 발생 여부<br>오버플로우 플래그: 오버플로우가 발생했는지<br>인터럽트 플래그: 인터럽트가 발생했는지<br>슈퍼바이저 플래그: 커널 모드/사용자 모드 실행 여부 |
| 스택 포인터   | 스택 영역의 마지막 데이터를 가리키는 레지스터.<br>(스택은 위 부터 넣고 뺀다. 즉 스택 영역 가장 위 메모리 주소)                                                                                                              |

### 인터럽트

![alt text](<../사진/Pasted image 20250812194930.png>)

입출력 장치처럼 CPU를 계속 대기 할당 하는 게 비효율적인 느린 작업에 사용.
인터럽트 발생 여부를 실행 사이클 마지막에 감시만 하다가.
입터럽트 발생 시에 실행 사이클을 잠시 메모리에 백업해두고.
인터럽트 사이클을 수행한다.
끝나면 다시 실행 사이클을 복구해서 수행한다.

```
						     ┌ 폴트 : 예외 발생 명령어부터 실행
        ┌ 동기 인터럽트 (예외) ┼ 트랩 : 예외 발생 다음 명령어부터 실행
        │                    ├ 중단 : 프로그램 중단
인터럽트 ┤                    └ 소프트웨어 인터럽트 : 시스템 콜 (3장에서 배움)
		│
        │                                 ┌ 막을 수 있는 인터럽트
		└ 비동기 인터럽트 (하드웨어 인터럽트) ┤
		                                  └ 막을 수 없는 인터럽트
```

비동시 인터럽트는 **인터럽트 플래그**에서 인터럽트를 무시할 수도 있는데,
사용하지 않을 입출력 장치를 무시 항목에 추가하는 등이 가능하다.
정전으로 인한 하드웨어 고장과 같은 중요 인터럽트의 경우 플래그로도 막을 수 없는 인터럽트도 있다.

실행 사이클에 예외가 발생했을 때도 CPU는 인터럽트로 처리하는 데,
어떻게 처리하냐에 따라서 3가지로 나뉜다.

1) 폴트 : 예) 함수 아규먼트 레지스터에 올리기.
2) 트랩 : 예) 디버그 브레이크
3) 중단 : 심각한 오류  

인터럽트 서비스 루틴은 일반 프로그램처럼 메모리에 올라가 있으며
인터럽트 대상(입출력 장치)에서 인터럽트 벡터를 통해 CPU에 서비스 루틴이 저장된 메모리 주소를 알려준다. 인터럽트와 인터럽트 벡터를 받으면 cpu는 실행 사이클을 보류하고 인터럽트를 수행한다.

### cpu 성능 설계

1) **클럭 속도**
   : 컴퓨터 부품을 움직이는 시간의 단위. 헤르츠(Hz)로 표현한다.
   일반적으로 CPU의 속도 단위를 말한다.
   
2) **멀티 코어 / 멀티 스레드**
   - 코어: CPU의 개수 (ALU / 레지스터를 묶어 모듈화 한것)
   - 스레드: 실행 흐름의 단위
	   - **하드웨어 스레드** : 하나의 코어로 동시에 실행할 수 있는 명령어 수
	   - **소프트웨어 스레드** : 하나의 프로그램에서 독립적으로 수행하는 단위
		(하드웨어 스레드와 소프웨어 스레드는 개념 자체가 다름 주의)
		
예) 1코어 4스레드 = 4개의 명령어를 동시 수행하는 코어가 1개. (하드웨어)

멀티 스레드로 구성한 소프트웨어는 멀티 스레드 코어에서 실행하면 병렬 수행이 가능해서 작업 속도가 빠르다. 하지만 하드웨어가 단일 스레드 코어더라도 멀티 스레드 소프트웨어를 돌릴 수는 있다.
여러 작업을 번갈아 가며 동시에 수행하면 단일 스레드 코어도 멀티 스레드를 실행하는 것처럼 보이게 할 수 있고 이를 동시성이라고 한다.

- **병렬성** : 하드웨어적으로 동시에 병렬 처리하는 것.
- **동시성** : 스레드를 번갈아 실행하여 동시에 처리되는 것처럼 보이게 하는 것.

(+번외. 멀티 스레드 구성 프로그램에는 멀티 코어가 좋은가 멀티 스레드가 좋은가)
### 멀티코어 vs 멀티스레드(SMT, 하이퍼스레딩)

#### 1. **멀티코어**

- 각 코어는 완전히 독립된 실행 장치(연산 장치, 파이프라인 등)를 가짐.
    
- 스레드가 코어마다 하나씩 배치되면 **진짜 병렬 실행** 가능.
    
- 예: 4코어 CPU는 동시에 4개의 스레드를 100% 성능으로 돌릴 수 있음.
    

👉 따라서 멀티코어 수가 많을수록 멀티스레드 프로그램 성능이 거의 선형적으로 증가.

---

#### 2. **멀티스레드(SMT, Hyper-Threading)**

- 코어 내부의 실행 유닛을 여러 스레드가 공유하는 방식.
    
- 예: 인텔 하이퍼스레딩(코어당 2스레드).
    
- CPU 자원을 100% 활용하지 못할 때(예: 메모리 대기, 파이프라인 유휴 시간), 다른 스레드가 대신 들어와 실행 → 효율 ↑.
    
- 하지만 물리적인 연산 장치가 늘어난 게 아니므로, 성능 향상은 **30~40% 정도**에 그침.
    

---

### 3. **결론**

- **멀티코어 > 멀티스레드(SMT)**
    
- 멀티스레드는 어디까지나 “보너스 최적화”이고, 진짜 성능 향상은 멀티코어에서 나옴.
    

---

✅ 정리하면:

- **멀티스레드 프로그램 실행 시** → 멀티코어가 훨씬 중요.
    
- 멀티스레드(SMT)는 멀티코어 위에 얹는 보조적인 성능 최적화.

CISC
RISC


### 명령어 파이프 라이닝 (단일 스레드 속도를 높이는 방식)

명령어 실행 과정에서 각 단계별로 쓰는 cpu의 ALU가 달라서
각 단계가 겹치지만 않는다면 동시에 여러 명령어를 위해 할당할 수 있다.

각 단계의 ALU를 이어서 다른 명령어에 할당하는 기법을 명령어 파이프 라이닝이라고 한다. 

1) 인출
2) 해석
3) 실행
4) 결과 저장

![alt text](<../사진/Pasted image 20250819104136.png>)
#### 파이프라이닝 위험

| 위험     |                                                                                                                                                              |
| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 데이터 위험 | 앞의 명령어의 결과 값이 뒤에 명령어의 참조값으로 쓰이는 경우,<br>아직 수행되지 않은 결과값을 참조하는 문제가 생긴다.<br>이를 방지하기 위해서는 지연이 발생한다.<br><br>예) <br>명령어1 : R1 ← R2 + R3  <br>명령어2 : R4 ← R1 * R2    |
| 제어 위험  | 분기로 인해 명령어 실행 흐름이 바뀌는 경우.<br>미리 실행해둔 명령어가 필요 없어지게 될 수 있다.<br>![alt text](<../사진/Pasted image 20250819104604.png>)                                            |
| 구조적 위험 | 명령어의 실행 구조가 달라서 단계가 겹치는 경우에 생기는 위험이다.<br>동시에 같은 ALU, 레지스터를 사용하려고 할 때 발생한다.<br><br>단계가 어긋나도록 뒤에 실행하는  명령어를 지연시켜 해결한다.<br>![alt text](<../사진/Pasted image 20250819104805.png>) |



슈퍼스칼라

## 메모리

### RAM

: 임의 접근 (random access memory)의 약자. 저장된 데이터의 메모리 위치에 순차 접근 할 필요 없이 직접 접근이  가능하기 때문에 접근 시간이 동일하다는 장점을 가지고 있다.

**휘발성**의 특징을 가진다.

| 종류        |                                                                                             |
| --------- | ------------------------------------------------------------------------------------------- |
| DRAM      | 시간이 지나면 데이터가 사라져서 주기적으로 재활성화(다시 저장)가 필요하다.                                                  |
| SRAM      | 전원이 공급되는 한 시간이 지나도 사라지지 않는다.<br>(전원이 공급되지 않으면 사라지는 휘발성은 동일하다.)                              |
| SDRAM     | Synchronous DRAM.<br>클럭 속도와 동기화된 DRAM의 발전 형태.                                               |
| DDR SDRAM | Double Data Rale.<br>두 배의 대역폭으로 한 클럭 당 두 번 CPU에 데이터를 공급할 수 있다.<br>너비가 두 배인 자동차 도로. 두 배 빠르다. |

### 메모리에 바이트를 저장하는 순서

| 순서     |                                                                                                                           |
| ------ | ------------------------------------------------------------------------------------------------------------------------- |
| 빅 엔디안  | **MSB** (=숫자 크기에 가장 큰 영향을 미치는 비트, 가장 왼쪽 비트)부터 낮은 번지 메모리에 저장하는 방식.<br>숫자를 읽을 때 저장한 **순서대로 읽으면 된다는 장점**이 있다.                |
| 리틀 엔디안 | **LSB**(=숫자 크기에 가장 작은 영향을 미치는 비트, 가장 오른쪽 비트)부터 낮은 번지 메모리에 저장하는 방식.<br><br>사칙 연산에서 낮은 비트부터 계산하는 게 일반적이므로, **연산 할 때 유리**하다. |
파이썬 코드로 빅 엔디안, 리틀 엔디안 방식을 구현한 코드가 인상적이었다.


### 캐시 메모리

CPU와 메인 메모리(DRAM) 사이에 위치한 메모리.
SRAM 기반.

CPU에 가까운 순서대로 L1, L2, L3 의 캐시 메모리가 존재하며,
L1, L2는 각 CPU코어마다 가지고 있고,
L3는 CPU 외부에 있는 경우가 일반적이다.

메모리가 실행 중인 데이터를 가지고 있다면,
캐시 메모리는 **CPU가 다음에 사용할 법한** 데이터를 가지고 있다.

#### 캐시 히트/미스
히트: 캐시 메모리가 예측한 데이터를 실제로 CPU가 사용한 경우.
미스: 예측에 실패해서 새로 필요한 데이터를 메모리에서 가져와야 하는 경우.

#### 참조 지역성의 원리
캐시메모리가 다음 데이터를 예측하는 테크닉.
CPU가 접근하는 데이터의 경향은 지역성을 띈다는 것에 기반해서 확률을 계산한다.

**시간 지역성**: 최근 접근한 메모리에 다시 접근하려는 경향이 있다. 
	예) 변수 - 자주 접근하기 위해 선언
**공간 지역성**: 접근한 메모리 공간 근처에 접근하려는 경향이 있다. 
	예) 배열 - 순서대로 접근하기 위해 선언

#### 쓰기 정책 / 일관성
캐시 메모리는 메모리와 값이 일치해야 한다. (일관성)
일관성의 원칙을 지키기 위해 쓰기 정책이 존재한다.

1) 즉시 쓰기 : 캐시 메모리에 씀과 동시에 메모리에도 쓴다. (캐시 메모리의 성능을 활용할 수 x)
2) 지연 쓰기 : 캐시에 먼저 쓰고 메모리에는 나중에 반영 (캐시 성능을 살릴 수 있지만 불일치 기간이 존재)